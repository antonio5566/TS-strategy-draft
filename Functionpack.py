{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "cb4a1449-b0c1-46aa-88ac-c5030a099bad",
   "metadata": {},
   "outputs": [],
   "source": [
    "#For plotting individual stock\n",
    "\n",
    "def calculate_stock_plot(sid,a,b, c, d):\n",
    "    start = datetime.datetime.now() - datetime.timedelta(days=a)\n",
    "    end = datetime.date.today()\n",
    "    \n",
    "\n",
    "    stock_yf = yf.download(sid+'.TW', start, end)\n",
    "    \n",
    "\n",
    "    stock_yf['SMA'] = stock_yf['Adj Close'].rolling(b).mean()\n",
    "    stock_yf['STD'] = stock_yf['Adj Close'].rolling(b).std()\n",
    "\n",
    "\n",
    "    stock_yf['upper'] = stock_yf['SMA'] + 1 * stock_yf['STD']\n",
    "    stock_yf['lower'] = stock_yf['SMA'] - 1 * stock_yf['STD']\n",
    "    \n",
    "\n",
    "    stock_yf['1.5upper'] = stock_yf['SMA'] + 1.5 * stock_yf['STD']\n",
    "    stock_yf['1.5lower'] = stock_yf['SMA'] - 1.5 * stock_yf['STD']\n",
    "    \n",
    " \n",
    "    stock_yf['EMA_short'] = stock_yf['Adj Close'].ewm(span=c, adjust=False).mean()\n",
    "    stock_yf['EMA_long'] = stock_yf['Adj Close'].ewm(span=d, adjust=False).mean()\n",
    "    stock_yf['Entry']=(stock_yf['EMA_short']>stock_yf['lower']) & (stock_yf['EMA_short'].shift(1)<stock_yf['lower'])\n",
    "    stock_yf['Exit']=(stock_yf['Adj Close']<stock_yf['upper']) & (stock_yf['Adj Close'].shift(1)>stock_yf['upper'])\n",
    "    \n",
    "    return stock_yf"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "73829de2-5cb3-49bd-ac79-6ab2b8dbad4b",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Calculate technical measurement for individual stock\n",
    "\n",
    "def calculate_stock(sid,a,b, c, d):\n",
    "    start = datetime.datetime.now() - datetime.timedelta(days=a)\n",
    "    end = datetime.date.today()\n",
    "    \n",
    "\n",
    "    stock_yf = yf.download(sid+'.TW', start, end)\n",
    "    \n",
    "\n",
    "    stock_yf['SMA'] = stock_yf['Adj Close'].rolling(b).mean()\n",
    "    stock_yf['STD'] = stock_yf['Adj Close'].rolling(b).std()\n",
    "\n",
    "\n",
    "    stock_yf['upper'] = stock_yf['SMA'] + 1 * stock_yf['STD']\n",
    "    stock_yf['lower'] = stock_yf['SMA'] - 1 * stock_yf['STD']\n",
    "    \n",
    "\n",
    "    stock_yf['1.5upper'] = stock_yf['SMA'] + 1.5 * stock_yf['STD']\n",
    "    stock_yf['1.5lower'] = stock_yf['SMA'] - 1.5 * stock_yf['STD']\n",
    "    \n",
    " \n",
    "    stock_yf['EMA_short'] = stock_yf['Adj Close'].ewm(span=c, adjust=False).mean()\n",
    "    stock_yf['EMA_long'] = stock_yf['Adj Close'].ewm(span=d, adjust=False).mean()\n",
    "    \n",
    "    btest=stock_yf.loc[:,['Adj Close','upper','lower','EMA_short','EMA_long']]\n",
    "    btest['Entry']=(btest['EMA_short']>btest['lower']) & (btest['EMA_short'].shift(1)<btest['lower'].shift(1))\n",
    "    btest['Exit']=(btest['Adj Close']<btest['upper']) & (btest['Adj Close'].shift(1)>btest['upper'].shift(1))\n",
    "\n",
    "    return btest "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7ee4eba3-c836-4bc2-a706-fbc4aaf74b27",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Display backtest result (DataFrame)\n",
    "\n",
    "def backtest_DF(btest):\n",
    "    spread_side = None\n",
    "    backtest_result = []\n",
    "    price = None\n",
    "    \n",
    "    for idx, row in btest.iterrows():\n",
    "        if spread_side is None:\n",
    "            if row['Entry']:\n",
    "                spread_side = \"buy\"\n",
    "                price = row['Adj Close']\n",
    "                return_stock = 0.0\n",
    "                backtest_result.append([idx, return_stock, spread_side, price])\n",
    "            \n",
    "        elif spread_side == \"buy\":\n",
    "            if row['Exit']:\n",
    "                spread_side = \"sell\"\n",
    "                return_stock = row['Adj Close'] / price - 1.0\n",
    "                price = row['Adj Close']\n",
    "                backtest_result.append([idx, return_stock, spread_side, price])\n",
    "                spread_side = None\n",
    "    backtest_df = pd.DataFrame(backtest_result, columns=['Date', 'Return', 'Spread_Side', 'Price'])\n",
    "    return backtest_df"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 7,
   "id": "ff888cc0-304d-4368-9912-073861e69e99",
   "metadata": {},
   "outputs": [],
   "source": [
    "#Calculate Total Return of the strategy within defined timeframe\n",
    "\n",
    "def backtest_TR(btest):\n",
    "    spread_side = None\n",
    "    backtest_result = []\n",
    "    price = None\n",
    "    \n",
    "    for idx, row in btest.iterrows():\n",
    "        if spread_side is None:\n",
    "            if row['Entry']:\n",
    "                spread_side = \"buy\"\n",
    "                price = row['Adj Close']\n",
    "                return_stock = 0.0\n",
    "                backtest_result.append([idx, return_stock, spread_side, price])\n",
    "            \n",
    "        elif spread_side == \"buy\":\n",
    "            if row['Exit']:\n",
    "                spread_side = \"sell\"\n",
    "                return_stock = row['Adj Close'] / price - 1.0\n",
    "                entry_price = row['Adj Close']\n",
    "                backtest_result.append([idx, return_stock, spread_side, price])\n",
    "                spread_side = None\n",
    "    backtest_df = pd.DataFrame(backtest_result, columns=['Date', 'Return', 'Spread_Side', 'Price'])\n",
    "    total_return = backtest_df['Return'].sum()*100\n",
    "    return total_return"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "1ee22058-c0e9-4787-98cc-085c17013263",
   "metadata": {},
   "outputs": [],
   "source": [
    "# Evaluate the ideal price range for entry tomorrow.\n",
    "\n",
    "def morgen_bp(sid,a,b, c, d):\n",
    "    value_list = [round(x * 0.001 + 1.0, 3) for x in range(400)]\n",
    "    start = datetime.datetime.now() - datetime.timedelta(days=a)\n",
    "    end = datetime.date.today()\n",
    "    stock_y = yf.download(sid+'.TW', start, end)\n",
    "    for v in value_list:\n",
    "        pre_close = v *stock_y['Adj Close'].iloc[-1]\n",
    "        new_row = pd.DataFrame({'Adj Close': [pre_close]}, index=[stock_y.index[-1] + pd.Timedelta(days=1)])\n",
    "        stock_yf = pd.concat([stock_y, new_row])\n",
    "        stock_yf = pd.DataFrame(stock_yf['Adj Close'])\n",
    "        stock_yf['SMA'] = stock_yf['Adj Close'].rolling(10).mean()\n",
    "        stock_yf['STD'] = stock_yf['Adj Close'].rolling(10).std()\n",
    "        stock_yf['upper'] = stock_yf['SMA'] + 1 * stock_yf['STD']\n",
    "        stock_yf['lower'] = stock_yf['SMA'] - 1 * stock_yf['STD']\n",
    "        stock_yf['1.5upper'] = stock_yf['SMA'] + 1.5 * stock_yf['STD']\n",
    "        stock_yf['EMA_short'] = stock_yf['Adj Close'].ewm(span=10, adjust=False).mean()\n",
    "        btest=stock_yf.loc[:,['Adj Close','upper','lower','EMA_short']]\n",
    "        if (btest['EMA_short'].iloc[-2]>btest['lower'].iloc[-2]):\n",
    "            print('Among bp')\n",
    "            break\n",
    "        elif (btest['EMA_short'].iloc[-1]>btest['lower'].iloc[-1]) and (btest['EMA_short'].iloc[-2]<btest['lower'].iloc[-2]):\n",
    "            print(btest,v) \n",
    "            break"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
